//: ----------------------------------------------------------------------------
//: Copyright (C) 2015 Lech GÅ‚owiak.  All Rights Reserved.
//:
//:   Licensed under the Apache License, Version 2.0 (the "License");
//:   you may not use this file except in compliance with the License.
//:   You may obtain a copy of the License at
//:
//:       http://www.apache.org/licenses/LICENSE-2.0
//:
//:   Unless required by applicable law or agreed to in writing, software
//:   distributed under the License is distributed on an "AS IS" BASIS,
//:   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//:   See the License for the specific language governing permissions and
//:   limitations under the License.
//:
//: ----------------------------------------------------------------------------

package remotely.transport.aeron

import java.nio.ByteBuffer
import java.util.concurrent.ExecutorService

import remotely._
import uk.co.real_logic.aeron.{Publication, Aeron}
import uk.co.real_logic.agrona.concurrent.UnsafeBuffer

import scalaz.{-\/, \/-}
import scalaz.concurrent.Task
import scalaz.stream.Process
import scalaz.stream.async.mutable.Queue

sealed trait AcceptorEvent

case class Closed(stream: StreamId) extends AcceptorEvent

case class StreamRequest(channel: String) extends AcceptorEvent

/*TODO: add some identifier generated by Acceptor when stream is requested
 to avoid disconnection by client that has timed out earlier.*/
case class Disconnect(stream: StreamId) extends AcceptorEvent

case class AcceptorWorkerState(id: WorkerId, free: Set[StreamId], taken: Set[StreamId], queue: Queue[WorkerEvent]) {
  def isAvailable(s: StreamId) = free.contains(s)
  def isTaken(s: StreamId) = taken.contains(s)

  val freeStreams: Int = free.size
}

class AcceptorState(m: Map[WorkerId, AcceptorWorkerState]) {

  def leastOccupied: AcceptorWorkerState = m.values.toSeq.sortBy(_.freeStreams * (-1)).head

  def mostOccupied: AcceptorWorkerState = m.values.toSeq.sortBy(_.freeStreams).head

  def streamReleased(s: StreamId): AcceptorState =
    m.values.find(_.isTaken(s)).map { w =>
      val w2 = w.copy(free = w.free + s, taken = w.taken - s)
      new AcceptorState(m.updated(w2.id, w2))
    }.getOrElse(this)

  def streamTaken(w: AcceptorWorkerState, s: StreamId): AcceptorState = {
    val w2 = w.copy(free = w.free - s, taken = w.taken + s)
    new AcceptorState(m.updated(w2.id, w2))
  }

  def enqueueClose(s: StreamId): AcceptorState = {
    m.values
      .find(_.taken.contains(s))
      .foreach(_.queue.enqueueOne(Close(s)).run)
    this
  }

  def workerQueues: Seq[(WorkerId, Queue[WorkerEvent])] = m.toSeq.map(kv => (kv._1, kv._2.queue))
}

class Acceptor(val aeron: Aeron,
               val logger: Monitoring,
               val es: ExecutorService,
               val srvChannel: String,
               val queue: Queue[AcceptorEvent],
               val workers: AcceptorState) {

  def process: Process[Task, AcceptorState] = {
    queue.dequeue.scan(workers)((states, e) => e match {
      case Closed(stream) =>
        log(s"Stream $stream was released")
        states.streamReleased(stream)
      case StreamRequest(channel) => //find worker with most free streams
        val ws = states.leastOccupied
        val streamIds = ws.free
        if (streamIds.nonEmpty) {
          val streamId = streamIds.head
          replyAndNotifyWorker(channel, streamId, ws)
          states.streamTaken(ws, streamId)
        } else {
          val pub = aeron.addPublication(channel, clientStream)
          sendStreamIdResponse(pub, -1)
          pub.close()
          states
        }
      case Disconnect(stream) =>
        log(s"Disconnect request with streamId: $stream")
        states.enqueueClose(stream)
    })
  }

  def log(msg: String): Unit = {
    logger.negotiating(None, msg, None)
  }

  def replyAndNotifyWorker(channel: String, stream: StreamId, ws: AcceptorWorkerState): Unit = {
    val pub = aeron.addPublication(channel, clientStream)
    sendStreamIdResponse(pub, stream)
    ws.queue.enqueueOne(Open(pub, stream)).run
  }

  def sendStreamIdResponse(pub: Publication, stream: StreamId): Unit = {
    val address = Some(addr(pub.channel()))
    val buf = new UnsafeBuffer(ByteBuffer.allocateDirect(4))
    buf.putInt(0, stream)
    offerResponse(pub, buf, "StreamId")(es).attemptRun match {
      case \/-(_) => logger.negotiating(address, s"StreamId: $stream sent", None)
      case -\/(t) => logger.negotiating(address, s"StreamId not sent", Some(t))
    }
  }

}